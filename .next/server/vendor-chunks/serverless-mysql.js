"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/serverless-mysql";
exports.ids = ["vendor-chunks/serverless-mysql"];
exports.modules = {

/***/ "(rsc)/./node_modules/serverless-mysql/index.js":
/*!************************************************!*\
  !*** ./node_modules/serverless-mysql/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst NodeURL = __webpack_require__(/*! url */ \"url\");\n/**\n * This module manages MySQL connections in serverless applications.\n * More detail regarding the MySQL module can be found here:\n * https://github.com/mysqljs/mysql\n * @author Jeremy Daly <jeremy@jeremydaly.com>\n * @version 1.5.4\n * @license MIT\n */ module.exports = (params)=>{\n    // Mutable values\n    let client = null // Init null client object\n    ;\n    let counter = 0 // Total reuses counter\n    ;\n    let errors = 0 // Error count\n    ;\n    let retries = 0 // Retry count\n    ;\n    let _cfg = {} // MySQL config globals\n    ;\n    let _maxConns = {\n        updated: 0\n    } // Cache max connections\n    ;\n    let _usedConns = {\n        updated: 0\n    } // Cache used connections\n    ;\n    // Common Too Many Connections Errors\n    const tooManyConnsErrors = [\n        \"ER_TOO_MANY_USER_CONNECTIONS\",\n        \"ER_CON_COUNT_ERROR\",\n        \"ER_USER_LIMIT_REACHED\",\n        \"ER_OUT_OF_RESOURCES\",\n        \"PROTOCOL_CONNECTION_LOST\",\n        \"PROTOCOL_SEQUENCE_TIMEOUT\",\n        \"ETIMEDOUT\" // if the connection times out\n    ];\n    // Init setting values\n    let MYSQL, manageConns, cap, base, maxRetries, connUtilization, backoff, zombieMinTimeout, zombieMaxTimeout, maxConnsFreq, usedConnsFreq, onConnect, onConnectError, onRetry, onClose, onError, onKill, onKillError, PromiseLibrary;\n    /********************************************************************/ /**  HELPER/CONVENIENCE FUNCTIONS                                  **/ /********************************************************************/ const getCounter = ()=>counter;\n    const incCounter = ()=>counter++;\n    const resetCounter = ()=>counter = 0;\n    const getClient = ()=>client;\n    const resetClient = ()=>client = null;\n    const resetRetries = ()=>retries = 0;\n    const getErrorCount = ()=>errors;\n    const getConfig = ()=>_cfg;\n    const config = (args)=>{\n        if (typeof args === \"string\") {\n            return Object.assign(_cfg, uriToConnectionConfig(args));\n        }\n        return Object.assign(_cfg, args);\n    };\n    const delay = (ms)=>new PromiseLibrary((res)=>setTimeout(res, ms));\n    const randRange = (min, max)=>Math.floor(Math.random() * (max - min + 1)) + min;\n    const fullJitter = ()=>randRange(0, Math.min(cap, base * 2 ** retries));\n    const decorrelatedJitter = (sleep = 0)=>Math.min(cap, randRange(base, sleep * 3));\n    const uriToConnectionConfig = (connectionString)=>{\n        let uri = undefined;\n        try {\n            uri = new NodeURL.URL(connectionString);\n        } catch (error) {\n            throw new Error(\"Invalid data source URL provided\");\n        }\n        const extraFields = {};\n        for (const [name, value] of uri.searchParams){\n            extraFields[name] = value;\n        }\n        const database = uri.pathname && uri.pathname.startsWith(\"/\") ? uri.pathname.slice(1) : undefined;\n        const connectionFields = {\n            host: uri.hostname ? uri.hostname : undefined,\n            user: uri.username ? uri.username : undefined,\n            port: uri.port ? Number(uri.port) : undefined,\n            password: uri.password ? uri.password : undefined,\n            database\n        };\n        return Object.assign(connectionFields, extraFields);\n    };\n    /********************************************************************/ /**  CONNECTION MANAGEMENT FUNCTIONS                               **/ /********************************************************************/ // Public connect method, handles backoff and catches\n    // TOO MANY CONNECTIONS errors\n    const connect = async (wait)=>{\n        try {\n            await _connect();\n        } catch (e) {\n            if (tooManyConnsErrors.includes(e.code) && retries < maxRetries) {\n                retries++;\n                wait = Number.isInteger(wait) ? wait : 0;\n                let sleep = backoff === \"decorrelated\" ? decorrelatedJitter(wait) : typeof backoff === \"function\" ? backoff(wait, retries) : fullJitter();\n                onRetry(e, retries, sleep, typeof backoff === \"function\" ? \"custom\" : backoff) // fire onRetry event\n                ;\n                await delay(sleep).then(()=>connect(sleep));\n            } else {\n                onConnectError(e) // Fire onConnectError event\n                ;\n                throw new Error(e);\n            }\n        }\n    } // end connect\n    ;\n    // Internal connect method\n    const _connect = ()=>{\n        if (client === null) {\n            resetCounter() // Reset the total use counter\n            ;\n            // Return a new promise\n            return new PromiseLibrary((resolve, reject)=>{\n                // Connect to the MySQL database\n                client = MYSQL.createConnection(_cfg);\n                // Wait until MySQL is connected and ready before moving on\n                client.connect(function(err) {\n                    if (err) {\n                        resetClient();\n                        reject(err);\n                    } else {\n                        resetRetries();\n                        onConnect(client);\n                        return resolve(true);\n                    }\n                });\n                // Add error listener (reset client on failures)\n                client.on(\"error\", async (err)=>{\n                    errors++;\n                    resetClient() // reset client\n                    ;\n                    resetCounter() // reset counter\n                    ;\n                    onError(err) // fire onError event (PROTOCOL_CONNECTION_LOST)\n                    ;\n                });\n            }) // end promise\n            ;\n        // Else the client already exists\n        } else {\n            return PromiseLibrary.resolve();\n        } // end if-else\n    } // end _connect\n    ;\n    // Function called at the end that attempts to clean up zombies\n    // and maintain proper connection limits\n    const end = async ()=>{\n        if (client !== null && manageConns) {\n            incCounter() // increment the reuse counter\n            ;\n            // Check the number of max connections\n            let maxConns = await getMaxConnections();\n            // Check the number of used connections\n            let usedConns = await getTotalConnections();\n            // If over utilization threshold, try and clean up zombies\n            if (usedConns.total / maxConns.total > connUtilization) {\n                // Calculate the zombie timeout\n                let timeout = Math.min(Math.max(usedConns.maxAge, zombieMinTimeout), zombieMaxTimeout);\n                // Kill zombies if they are within the timeout\n                let killedZombies = timeout <= usedConns.maxAge ? await killZombieConnections(timeout) : 0;\n                // If no zombies were cleaned up, close this connection\n                if (killedZombies === 0) {\n                    quit();\n                }\n            // If zombies exist that are more than the max timeout, kill them\n            } else if (usedConns.maxAge > zombieMaxTimeout) {\n                await killZombieConnections(zombieMaxTimeout);\n            }\n        } // end if client\n    } // end end() method\n    ;\n    // Function that explicitly closes the MySQL connection.\n    const quit = ()=>{\n        if (client !== null) {\n            client.end() // Quit the connection.\n            ;\n            resetClient() // reset the client to null\n            ;\n            resetCounter() // reset the reuse counter\n            ;\n            onClose() // fire onClose event\n            ;\n        }\n    };\n    /********************************************************************/ /**  QUERY FUNCTIONS                                               **/ /********************************************************************/ // Main query function\n    const query = async function(...args) {\n        // Establish connection\n        await connect();\n        // Run the query\n        return new PromiseLibrary((resolve, reject)=>{\n            if (client !== null) {\n                // If no args are passed in a transaction, ignore query\n                if (this && this.rollback && args.length === 0) {\n                    return resolve([]);\n                }\n                client.query(...args, async (err, results)=>{\n                    if (err && err.code === \"PROTOCOL_SEQUENCE_TIMEOUT\") {\n                        client.destroy() // destroy connection on timeout\n                        ;\n                        resetClient() // reset the client\n                        ;\n                        reject(err) // reject the promise with the error\n                        ;\n                    } else if (err && (/^PROTOCOL_ENQUEUE_AFTER_/.test(err.code) || err.code === \"PROTOCOL_CONNECTION_LOST\" || err.code === \"EPIPE\" || err.code === \"ECONNRESET\")) {\n                        resetClient() // reset the client\n                        ;\n                        return resolve(query(...args)) // attempt the query again\n                        ;\n                    } else if (err) {\n                        if (this && this.rollback) {\n                            await query(\"ROLLBACK\");\n                            this.rollback(err);\n                        }\n                        reject(err);\n                    }\n                    return resolve(results);\n                });\n            }\n        });\n    } // end query\n    ;\n    // Get the max connections (either for this user or total)\n    const getMaxConnections = async ()=>{\n        // If cache is expired\n        if (Date.now() - _maxConns.updated > maxConnsFreq) {\n            let results = await query(`SELECT IF(@@max_user_connections > 0,\n        LEAST(@@max_user_connections,@@max_connections),\n        @@max_connections) AS total,\n        IF(@@max_user_connections > 0,true,false) AS userLimit`);\n            // Update _maxConns\n            _maxConns = {\n                total: results[0].total || 0,\n                userLimit: results[0].userLimit === 1 ? true : false,\n                updated: Date.now()\n            };\n        } // end if renewing cache\n        return _maxConns;\n    } // end getMaxConnections\n    ;\n    // Get the total connections being used and the longest sleep time\n    const getTotalConnections = async ()=>{\n        // If cache is expired\n        if (Date.now() - _usedConns.updated > usedConnsFreq) {\n            let results = await query(`SELECT COUNT(ID) as total, MAX(time) as max_age\n        FROM information_schema.processlist\n        WHERE (user = ? AND @@max_user_connections > 0) OR true`, [\n                _cfg.user\n            ]);\n            _usedConns = {\n                total: results[0].total || 0,\n                maxAge: results[0].max_age || 0,\n                updated: Date.now()\n            };\n        } // end if refreshing cache\n        return _usedConns;\n    } // end getTotalConnections\n    ;\n    // Kill all zombie connections that are older than the threshold\n    const killZombieConnections = async (timeout)=>{\n        let killedZombies = 0;\n        // Hunt for zombies (just the sleeping ones that this user owns)\n        let zombies = await query(`SELECT ID,time FROM information_schema.processlist\n        WHERE command = 'Sleep' AND time >= ? AND user = ?\n        ORDER BY time DESC`, [\n            !isNaN(timeout) ? timeout : 60 * 15,\n            _cfg.user\n        ]);\n        // Kill zombies\n        for(let i = 0; i < zombies.length; i++){\n            try {\n                await query(\"KILL ?\", zombies[i].ID);\n                onKill(zombies[i]) // fire onKill event\n                ;\n                killedZombies++;\n            } catch (e) {\n                // if (e.code !== 'ER_NO_SUCH_THREAD') console.log(e)\n                onKillError(e) // fire onKillError event\n                ;\n            }\n        } // end for\n        return killedZombies;\n    } // end killZombieConnections\n    ;\n    /********************************************************************/ /**  TRANSACTION MANAGEMENT                                        **/ /********************************************************************/ // Init a transaction object and return methods\n    const transaction = ()=>{\n        let queries = [] // keep track of queries\n        ;\n        let rollback = ()=>{} // default rollback event\n        ;\n        return {\n            query: function(...args) {\n                if (typeof args[0] === \"function\") {\n                    queries.push(args[0]);\n                } else {\n                    queries.push(()=>[\n                            ...args\n                        ]);\n                }\n                return this;\n            },\n            rollback: function(fn) {\n                if (typeof fn === \"function\") {\n                    rollback = fn;\n                }\n                return this;\n            },\n            commit: async function() {\n                return await commit(queries, rollback);\n            }\n        };\n    };\n    // Commit transaction by running queries\n    const commit = async (queries, rollback)=>{\n        let results = [] // keep track of results\n        ;\n        // Start a transaction\n        await query(\"START TRANSACTION\");\n        // Loop through queries\n        for(let i = 0; i < queries.length; i++){\n            // Execute the queries, pass the rollback as context\n            let result = await query.apply({\n                rollback\n            }, queries[i](results[results.length - 1], results));\n            // Add the result to the main results accumulator\n            results.push(result);\n        }\n        // Commit our transaction\n        await query(\"COMMIT\");\n        // Return the results\n        return results;\n    };\n    /********************************************************************/ /**  INITIALIZATION                                                **/ /********************************************************************/ const cfg = typeof params === \"object\" && !Array.isArray(params) ? params : {};\n    MYSQL = cfg.library || __webpack_require__(/*! mysql */ \"(rsc)/./node_modules/mysql/index.js\");\n    PromiseLibrary = cfg.promise || Promise;\n    // Set defaults for connection management\n    manageConns = cfg.manageConns === false ? false : true // default to true\n    ;\n    cap = Number.isInteger(cfg.cap) ? cfg.cap : 100 // default to 100 ms\n    ;\n    base = Number.isInteger(cfg.base) ? cfg.base : 2 // default to 2 ms\n    ;\n    maxRetries = Number.isInteger(cfg.maxRetries) ? cfg.maxRetries : 50 // default to 50 attempts\n    ;\n    backoff = typeof cfg.backoff === \"function\" ? cfg.backoff : cfg.backoff && [\n        \"full\",\n        \"decorrelated\"\n    ].includes(cfg.backoff.toLowerCase()) ? cfg.backoff.toLowerCase() : \"full\" // default to full Jitter\n    ;\n    connUtilization = !isNaN(cfg.connUtilization) ? cfg.connUtilization : 0.8 // default to 0.7\n    ;\n    zombieMinTimeout = Number.isInteger(cfg.zombieMinTimeout) ? cfg.zombieMinTimeout : 3 // default to 3 seconds\n    ;\n    zombieMaxTimeout = Number.isInteger(cfg.zombieMaxTimeout) ? cfg.zombieMaxTimeout : 60 * 15 // default to 15 minutes\n    ;\n    maxConnsFreq = Number.isInteger(cfg.maxConnsFreq) ? cfg.maxConnsFreq : 15 * 1000 // default to 15 seconds\n    ;\n    usedConnsFreq = Number.isInteger(cfg.usedConnsFreq) ? cfg.usedConnsFreq : 0 // default to 0 ms\n    ;\n    // Event handlers\n    onConnect = typeof cfg.onConnect === \"function\" ? cfg.onConnect : ()=>{};\n    onConnectError = typeof cfg.onConnectError === \"function\" ? cfg.onConnectError : ()=>{};\n    onRetry = typeof cfg.onRetry === \"function\" ? cfg.onRetry : ()=>{};\n    onClose = typeof cfg.onClose === \"function\" ? cfg.onClose : ()=>{};\n    onError = typeof cfg.onError === \"function\" ? cfg.onError : ()=>{};\n    onKill = typeof cfg.onKill === \"function\" ? cfg.onKill : ()=>{};\n    onKillError = typeof cfg.onKillError === \"function\" ? cfg.onKillError : ()=>{};\n    let connCfg = {};\n    if (typeof cfg.config === \"object\" && !Array.isArray(cfg.config)) {\n        connCfg = cfg.config;\n    } else if (typeof params === \"string\") {\n        connCfg = params;\n    }\n    let escape = MYSQL.escape;\n    let escapeId = MYSQL.escapeId;\n    let format = MYSQL.format;\n    // Set MySQL configs\n    config(connCfg);\n    // Return public methods\n    return {\n        connect,\n        config,\n        query,\n        end,\n        escape,\n        escapeId,\n        format,\n        quit,\n        transaction,\n        getCounter,\n        getClient,\n        getConfig,\n        getErrorCount\n    };\n} // end exports\n;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc2VydmVybGVzcy1teXNxbC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU1BLFVBQVVDLG1CQUFPQSxDQUFDO0FBRXhCOzs7Ozs7O0NBT0MsR0FFREMsT0FBT0MsT0FBTyxHQUFHLENBQUNDO0lBRWhCLGlCQUFpQjtJQUNqQixJQUFJQyxTQUFTLEtBQUssMEJBQTBCOztJQUM1QyxJQUFJQyxVQUFVLEVBQUUsdUJBQXVCOztJQUN2QyxJQUFJQyxTQUFTLEVBQUUsY0FBYzs7SUFDN0IsSUFBSUMsVUFBVSxFQUFFLGNBQWM7O0lBQzlCLElBQUlDLE9BQU8sQ0FBQyxFQUFFLHVCQUF1Qjs7SUFFckMsSUFBSUMsWUFBWTtRQUFFQyxTQUFTO0lBQUUsRUFBRSx3QkFBd0I7O0lBQ3ZELElBQUlDLGFBQWE7UUFBRUQsU0FBUztJQUFFLEVBQUUseUJBQXlCOztJQUV6RCxxQ0FBcUM7SUFDckMsTUFBTUUscUJBQXFCO1FBQ3pCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLFlBQVksOEJBQThCO0tBQzNDO0lBRUQsc0JBQXNCO0lBQ3RCLElBQUlDLE9BQU9DLGFBQWFDLEtBQUtDLE1BQU1DLFlBQVlDLGlCQUFpQkMsU0FDOURDLGtCQUFrQkMsa0JBQWtCQyxjQUFjQyxlQUNsREMsV0FBV0MsZ0JBQWdCQyxTQUFTQyxTQUFTQyxTQUFTQyxRQUFRQyxhQUFhQztJQUU3RSxvRUFBb0UsR0FDcEUsb0VBQW9FLEdBQ3BFLG9FQUFvRSxHQUVwRSxNQUFNQyxhQUFhLElBQU0zQjtJQUN6QixNQUFNNEIsYUFBYSxJQUFNNUI7SUFDekIsTUFBTTZCLGVBQWUsSUFBTTdCLFVBQVU7SUFDckMsTUFBTThCLFlBQVksSUFBTS9CO0lBQ3hCLE1BQU1nQyxjQUFjLElBQU1oQyxTQUFTO0lBQ25DLE1BQU1pQyxlQUFlLElBQU05QixVQUFVO0lBQ3JDLE1BQU0rQixnQkFBZ0IsSUFBTWhDO0lBQzVCLE1BQU1pQyxZQUFZLElBQU0vQjtJ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SUFDbkVDLFVBQVUsT0FBT2tHLElBQUlsRyxPQUFPLEtBQUssYUFBYWtHLElBQUlsRyxPQUFPLEdBQUcsS0FBTztJQUNuRUMsVUFBVSxPQUFPaUcsSUFBSWpHLE9BQU8sS0FBSyxhQUFhaUcsSUFBSWpHLE9BQU8sR0FBRyxLQUFPO0lBQ25FQyxTQUFTLE9BQU9nRyxJQUFJaEcsTUFBTSxLQUFLLGFBQWFnRyxJQUFJaEcsTUFBTSxHQUFHLEtBQU87SUFDaEVDLGNBQWMsT0FBTytGLElBQUkvRixXQUFXLEtBQUssYUFBYStGLElBQUkvRixXQUFXLEdBQUcsS0FBTztJQUUvRSxJQUFJc0csVUFBVSxDQUFDO0lBRWYsSUFBSSxPQUFPUCxJQUFJckYsTUFBTSxLQUFLLFlBQVksQ0FBQ3NGLE1BQU1DLE9BQU8sQ0FBQ0YsSUFBSXJGLE1BQU0sR0FBRztRQUNoRTRGLFVBQVVQLElBQUlyRixNQUFNO0lBQ3RCLE9BQU8sSUFBSSxPQUFPckMsV0FBVyxVQUFVO1FBQ3JDaUksVUFBVWpJO0lBQ1o7SUFFQSxJQUFJa0ksU0FBU3hILE1BQU13SCxNQUFNO0lBQ3pCLElBQUlDLFdBQVd6SCxNQUFNeUgsUUFBUTtJQUM3QixJQUFJQyxTQUFTMUgsTUFBTTBILE1BQU07SUFFekIsb0JBQW9CO0lBQ3BCL0YsT0FBTzRGO0lBR1Asd0JBQXdCO0lBQ3hCLE9BQU87UUFDTHBEO1FBQ0F4QztRQUNBZ0U7UUFDQVg7UUFDQXdDO1FBQ0FDO1FBQ0FDO1FBQ0FoQztRQUNBZTtRQUNBdEY7UUFDQUc7UUFDQUk7UUFDQUQ7SUFDRjtBQUVGLEVBQUUsY0FBYyIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRhcHAvLi9ub2RlX21vZHVsZXMvc2VydmVybGVzcy1teXNxbC9pbmRleC5qcz9jZjlmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBOb2RlVVJMID0gcmVxdWlyZSgndXJsJylcblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBtYW5hZ2VzIE15U1FMIGNvbm5lY3Rpb25zIGluIHNlcnZlcmxlc3MgYXBwbGljYXRpb25zLlxuICogTW9yZSBkZXRhaWwgcmVnYXJkaW5nIHRoZSBNeVNRTCBtb2R1bGUgY2FuIGJlIGZvdW5kIGhlcmU6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbXlzcWxqcy9teXNxbFxuICogQGF1dGhvciBKZXJlbXkgRGFseSA8amVyZW15QGplcmVteWRhbHkuY29tPlxuICogQHZlcnNpb24gMS41LjRcbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gKHBhcmFtcykgPT4ge1xuXG4gIC8vIE11dGFibGUgdmFsdWVzXG4gIGxldCBjbGllbnQgPSBudWxsIC8vIEluaXQgbnVsbCBjbGllbnQgb2JqZWN0XG4gIGxldCBjb3VudGVyID0gMCAvLyBUb3RhbCByZXVzZXMgY291bnRlclxuICBsZXQgZXJyb3JzID0gMCAvLyBFcnJvciBjb3VudFxuICBsZXQgcmV0cmllcyA9IDAgLy8gUmV0cnkgY291bnRcbiAgbGV0IF9jZmcgPSB7fSAvLyBNeVNRTCBjb25maWcgZ2xvYmFsc1xuXG4gIGxldCBfbWF4Q29ubnMgPSB7IHVwZGF0ZWQ6IDAgfSAvLyBDYWNoZSBtYXggY29ubmVjdGlvbnNcbiAgbGV0IF91c2VkQ29ubnMgPSB7IHVwZGF0ZWQ6IDAgfSAvLyBDYWNoZSB1c2VkIGNvbm5lY3Rpb25zXG5cbiAgLy8gQ29tbW9uIFRvbyBNYW55IENvbm5lY3Rpb25zIEVycm9yc1xuICBjb25zdCB0b29NYW55Q29ubnNFcnJvcnMgPSBbXG4gICAgJ0VSX1RPT19NQU5ZX1VTRVJfQ09OTkVDVElPTlMnLFxuICAgICdFUl9DT05fQ09VTlRfRVJST1InLFxuICAgICdFUl9VU0VSX0xJTUlUX1JFQUNIRUQnLFxuICAgICdFUl9PVVRfT0ZfUkVTT1VSQ0VTJyxcbiAgICAnUFJPVE9DT0xfQ09OTkVDVElPTl9MT1NUJywgLy8gaWYgdGhlIGNvbm5lY3Rpb24gaXMgbG9zdFxuICAgICdQUk9UT0NPTF9TRVFVRU5DRV9USU1FT1VUJywgLy8gaWYgdGhlIGNvbm5lY3Rpb24gdGltZXMgb3V0XG4gICAgJ0VUSU1FRE9VVCcgLy8gaWYgdGhlIGNvbm5lY3Rpb24gdGltZXMgb3V0XG4gIF1cblxuICAvLyBJbml0IHNldHRpbmcgdmFsdWVzXG4gIGxldCBNWVNRTCwgbWFuYWdlQ29ubnMsIGNhcCwgYmFzZSwgbWF4UmV0cmllcywgY29ublV0aWxpemF0aW9uLCBiYWNrb2ZmLFxuICAgIHpvbWJpZU1pblRpbWVvdXQsIHpvbWJpZU1heFRpbWVvdXQsIG1heENvbm5zRnJlcSwgdXNlZENvbm5zRnJlcSxcbiAgICBvbkNvbm5lY3QsIG9uQ29ubmVjdEVycm9yLCBvblJldHJ5LCBvbkNsb3NlLCBvbkVycm9yLCBvbktpbGwsIG9uS2lsbEVycm9yLCBQcm9taXNlTGlicmFyeVxuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyoqICBIRUxQRVIvQ09OVkVOSUVOQ0UgRlVOQ1RJT05TICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgY29uc3QgZ2V0Q291bnRlciA9ICgpID0+IGNvdW50ZXJcbiAgY29uc3QgaW5jQ291bnRlciA9ICgpID0+IGNvdW50ZXIrK1xuICBjb25zdCByZXNldENvdW50ZXIgPSAoKSA9PiBjb3VudGVyID0gMFxuICBjb25zdCBnZXRDbGllbnQgPSAoKSA9PiBjbGllbnRcbiAgY29uc3QgcmVzZXRDbGllbnQgPSAoKSA9PiBjbGllbnQgPSBudWxsXG4gIGNvbnN0IHJlc2V0UmV0cmllcyA9ICgpID0+IHJldHJpZXMgPSAwXG4gIGNvbnN0IGdldEVycm9yQ291bnQgPSAoKSA9PiBlcnJvcnNcbiAgY29uc3QgZ2V0Q29uZmlnID0gKCkgPT4gX2NmZ1xuICBjb25zdCBjb25maWcgPSAoYXJncykgPT4ge1xuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKF9jZmcsdXJpVG9Db25uZWN0aW9uQ29uZmlnKGFyZ3MpKVxuICAgIH0gXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oX2NmZyxhcmdzKVxuICB9XG4gIGNvbnN0IGRlbGF5ID0gbXMgPT4gbmV3IFByb21pc2VMaWJyYXJ5KHJlcyA9PiBzZXRUaW1lb3V0KHJlcywgbXMpKVxuICBjb25zdCByYW5kUmFuZ2UgPSAobWluLG1heCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKSArIG1pblxuICBjb25zdCBmdWxsSml0dGVyID0gKCkgPT4gcmFuZFJhbmdlKDAsIE1hdGgubWluKGNhcCwgYmFzZSAqIDIgKiogcmV0cmllcykpXG4gIGNvbnN0IGRlY29ycmVsYXRlZEppdHRlciA9IChzbGVlcD0wKSA9PiBNYXRoLm1pbihjYXAsIHJhbmRSYW5nZShiYXNlLCBzbGVlcCAqIDMpKVxuICBjb25zdCB1cmlUb0Nvbm5lY3Rpb25Db25maWcgPSAoY29ubmVjdGlvblN0cmluZykgPT4ge1xuICAgIGxldCB1cmkgPSB1bmRlZmluZWRcblxuICAgIHRyeSB7XG4gICAgICB1cmkgPSBuZXcgTm9kZVVSTC5VUkwoY29ubmVjdGlvblN0cmluZylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRhdGEgc291cmNlIFVSTCBwcm92aWRlZCcpXG4gICAgfVxuXG4gICAgY29uc3QgZXh0cmFGaWVsZHMgPSB7fVxuXG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIHVyaS5zZWFyY2hQYXJhbXMpIHtcbiAgICAgIGV4dHJhRmllbGRzW25hbWVdID0gdmFsdWVcbiAgICB9XG5cbiAgICBjb25zdCBkYXRhYmFzZSA9IHVyaS5wYXRobmFtZSAmJiB1cmkucGF0aG5hbWUuc3RhcnRzV2l0aCgnLycpID8gdXJpLnBhdGhuYW1lLnNsaWNlKDEpIDogdW5kZWZpbmVkICBcblxuICAgIGNvbnN0IGNvbm5lY3Rpb25GaWVsZHMgPSAge1xuICAgICAgaG9zdDogdXJpLmhvc3RuYW1lID8gdXJpLmhvc3RuYW1lIDogdW5kZWZpbmVkLFxuICAgICAgdXNlcjogdXJpLnVzZXJuYW1lID8gdXJpLnVzZXJuYW1lIDogdW5kZWZpbmVkLFxuICAgICAgcG9ydDogdXJpLnBvcnQgPyBOdW1iZXIodXJpLnBvcnQpIDogdW5kZWZpbmVkLFxuICAgICAgcGFzc3dvcmQ6IHVyaS5wYXNzd29yZCA/IHVyaS5wYXNzd29yZCA6IHVuZGVmaW5lZCxcbiAgICAgIGRhdGFiYXNlXG4gICAgfVxuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oY29ubmVjdGlvbkZpZWxkcywgZXh0cmFGaWVsZHMpXG4gIH1cblxuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyoqICBDT05ORUNUSU9OIE1BTkFHRU1FTlQgRlVOQ1RJT05TICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLy8gUHVibGljIGNvbm5lY3QgbWV0aG9kLCBoYW5kbGVzIGJhY2tvZmYgYW5kIGNhdGNoZXNcbiAgLy8gVE9PIE1BTlkgQ09OTkVDVElPTlMgZXJyb3JzXG4gIGNvbnN0IGNvbm5lY3QgPSBhc3luYyAod2FpdCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBfY29ubmVjdCgpXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBpZiAodG9vTWFueUNvbm5zRXJyb3JzLmluY2x1ZGVzKGUuY29kZSkgJiYgcmV0cmllcyA8IG1heFJldHJpZXMpIHtcbiAgICAgICAgcmV0cmllcysrXG4gICAgICAgIHdhaXQgPSBOdW1iZXIuaXNJbnRlZ2VyKHdhaXQpID8gd2FpdCA6IDBcbiAgICAgICAgbGV0IHNsZWVwID0gYmFja29mZiA9PT0gJ2RlY29ycmVsYXRlZCcgPyBkZWNvcnJlbGF0ZWRKaXR0ZXIod2FpdCkgOlxuICAgICAgICAgIHR5cGVvZiBiYWNrb2ZmID09PSAnZnVuY3Rpb24nID8gYmFja29mZih3YWl0LHJldHJpZXMpIDpcbiAgICAgICAgICAgIGZ1bGxKaXR0ZXIoKVxuICAgICAgICBvblJldHJ5KGUscmV0cmllcyxzbGVlcCx0eXBlb2YgYmFja29mZiA9PT0gJ2Z1bmN0aW9uJyA/ICdjdXN0b20nIDogYmFja29mZikgLy8gZmlyZSBvblJldHJ5IGV2ZW50XG4gICAgICAgIGF3YWl0IGRlbGF5KHNsZWVwKS50aGVuKCgpID0+IGNvbm5lY3Qoc2xlZXApKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb25Db25uZWN0RXJyb3IoZSkgLy8gRmlyZSBvbkNvbm5lY3RFcnJvciBldmVudFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZSlcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gZW5kIGNvbm5lY3RcblxuICAvLyBJbnRlcm5hbCBjb25uZWN0IG1ldGhvZFxuICBjb25zdCBfY29ubmVjdCA9ICgpID0+IHtcblxuICAgIGlmIChjbGllbnQgPT09IG51bGwpIHsgLy8gaWYgbm8gY2xpZW50IGNvbm5lY3Rpb24gZXhpc3RzXG5cbiAgICAgIHJlc2V0Q291bnRlcigpIC8vIFJlc2V0IHRoZSB0b3RhbCB1c2UgY291bnRlclxuXG4gICAgICAvLyBSZXR1cm4gYSBuZXcgcHJvbWlzZVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlTGlicmFyeSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cbiAgICAgICAgLy8gQ29ubmVjdCB0byB0aGUgTXlTUUwgZGF0YWJhc2VcbiAgICAgICAgY2xpZW50ID0gTVlTUUwuY3JlYXRlQ29ubmVjdGlvbihfY2ZnKVxuXG4gICAgICAgIC8vIFdhaXQgdW50aWwgTXlTUUwgaXMgY29ubmVjdGVkIGFuZCByZWFkeSBiZWZvcmUgbW92aW5nIG9uXG4gICAgICAgIGNsaWVudC5jb25uZWN0KGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIHJlc2V0Q2xpZW50KClcbiAgICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc2V0UmV0cmllcygpXG4gICAgICAgICAgICBvbkNvbm5lY3QoY2xpZW50KVxuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodHJ1ZSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgLy8gQWRkIGVycm9yIGxpc3RlbmVyIChyZXNldCBjbGllbnQgb24gZmFpbHVyZXMpXG4gICAgICAgIGNsaWVudC5vbignZXJyb3InLCBhc3luYyBlcnIgPT4ge1xuICAgICAgICAgIGVycm9ycysrXG4gICAgICAgICAgcmVzZXRDbGllbnQoKSAvLyByZXNldCBjbGllbnRcbiAgICAgICAgICByZXNldENvdW50ZXIoKSAvLyByZXNldCBjb3VudGVyXG4gICAgICAgICAgb25FcnJvcihlcnIpIC8vIGZpcmUgb25FcnJvciBldmVudCAoUFJPVE9DT0xfQ09OTkVDVElPTl9MT1NUKVxuICAgICAgICB9KVxuICAgICAgfSkgLy8gZW5kIHByb21pc2VcblxuICAgIC8vIEVsc2UgdGhlIGNsaWVudCBhbHJlYWR5IGV4aXN0c1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZUxpYnJhcnkucmVzb2x2ZSgpXG4gICAgfSAvLyBlbmQgaWYtZWxzZVxuXG4gIH0gLy8gZW5kIF9jb25uZWN0XG5cblxuICAvLyBGdW5jdGlvbiBjYWxsZWQgYXQgdGhlIGVuZCB0aGF0IGF0dGVtcHRzIHRvIGNsZWFuIHVwIHpvbWJpZXNcbiAgLy8gYW5kIG1haW50YWluIHByb3BlciBjb25uZWN0aW9uIGxpbWl0c1xuICBjb25zdCBlbmQgPSBhc3luYyAoKSA9PiB7XG5cbiAgICBpZiAoY2xpZW50ICE9PSBudWxsICYmIG1hbmFnZUNvbm5zKSB7XG5cbiAgICAgIGluY0NvdW50ZXIoKSAvLyBpbmNyZW1lbnQgdGhlIHJldXNlIGNvdW50ZXJcblxuICAgICAgLy8gQ2hlY2sgdGhlIG51bWJlciBvZiBtYXggY29ubmVjdGlvbnNcbiAgICAgIGxldCBtYXhDb25ucyA9IGF3YWl0IGdldE1heENvbm5lY3Rpb25zKClcblxuICAgICAgLy8gQ2hlY2sgdGhlIG51bWJlciBvZiB1c2VkIGNvbm5lY3Rpb25zXG4gICAgICBsZXQgdXNlZENvbm5zID0gYXdhaXQgZ2V0VG90YWxDb25uZWN0aW9ucygpXG5cbiAgICAgIC8vIElmIG92ZXIgdXRpbGl6YXRpb24gdGhyZXNob2xkLCB0cnkgYW5kIGNsZWFuIHVwIHpvbWJpZXNcbiAgICAgIGlmICh1c2VkQ29ubnMudG90YWwvbWF4Q29ubnMudG90YWwgPiBjb25uVXRpbGl6YXRpb24pIHtcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHpvbWJpZSB0aW1lb3V0XG4gICAgICAgIGxldCB0aW1lb3V0ID0gTWF0aC5taW4oTWF0aC5tYXgodXNlZENvbm5zLm1heEFnZSx6b21iaWVNaW5UaW1lb3V0KSx6b21iaWVNYXhUaW1lb3V0KVxuXG4gICAgICAgIC8vIEtpbGwgem9tYmllcyBpZiB0aGV5IGFyZSB3aXRoaW4gdGhlIHRpbWVvdXRcbiAgICAgICAgbGV0IGtpbGxlZFpvbWJpZXMgPSB0aW1lb3V0IDw9IHVzZWRDb25ucy5tYXhBZ2UgPyBhd2FpdCBraWxsWm9tYmllQ29ubmVjdGlvbnModGltZW91dCkgOiAwXG5cbiAgICAgICAgLy8gSWYgbm8gem9tYmllcyB3ZXJlIGNsZWFuZWQgdXAsIGNsb3NlIHRoaXMgY29ubmVjdGlvblxuICAgICAgICBpZiAoa2lsbGVkWm9tYmllcyA9PT0gMCkge1xuICAgICAgICAgIHF1aXQoKVxuICAgICAgICB9XG5cbiAgICAgIC8vIElmIHpvbWJpZXMgZXhpc3QgdGhhdCBhcmUgbW9yZSB0aGFuIHRoZSBtYXggdGltZW91dCwga2lsbCB0aGVtXG4gICAgICB9IGVsc2UgaWYgKHVzZWRDb25ucy5tYXhBZ2UgPiB6b21iaWVNYXhUaW1lb3V0KSB7XG4gICAgICAgIGF3YWl0IGtpbGxab21iaWVDb25uZWN0aW9ucyh6b21iaWVNYXhUaW1lb3V0KVxuICAgICAgfVxuICAgIH0gLy8gZW5kIGlmIGNsaWVudFxuICB9IC8vIGVuZCBlbmQoKSBtZXRob2RcblxuXG4gIC8vIEZ1bmN0aW9uIHRoYXQgZXhwbGljaXRseSBjbG9zZXMgdGhlIE15U1FMIGNvbm5lY3Rpb24uXG4gIGNvbnN0IHF1aXQgPSAoKSA9PiB7XG4gICAgaWYgKGNsaWVudCAhPT0gbnVsbCkge1xuICAgICAgY2xpZW50LmVuZCgpIC8vIFF1aXQgdGhlIGNvbm5lY3Rpb24uXG4gICAgICByZXNldENsaWVudCgpIC8vIHJlc2V0IHRoZSBjbGllbnQgdG8gbnVsbFxuICAgICAgcmVzZXRDb3VudGVyKCkgLy8gcmVzZXQgdGhlIHJldXNlIGNvdW50ZXJcbiAgICAgIG9uQ2xvc2UoKSAvLyBmaXJlIG9uQ2xvc2UgZXZlbnRcbiAgICB9XG4gIH1cblxuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyoqICBRVUVSWSBGVU5DVElPTlMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLy8gTWFpbiBxdWVyeSBmdW5jdGlvblxuICBjb25zdCBxdWVyeSA9IGFzeW5jIGZ1bmN0aW9uKC4uLmFyZ3MpIHtcblxuICAgIC8vIEVzdGFibGlzaCBjb25uZWN0aW9uXG4gICAgYXdhaXQgY29ubmVjdCgpXG5cbiAgICAvLyBSdW4gdGhlIHF1ZXJ5XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlTGlicmFyeSgocmVzb2x2ZSxyZWplY3QpID0+IHtcbiAgICAgIGlmIChjbGllbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgbm8gYXJncyBhcmUgcGFzc2VkIGluIGEgdHJhbnNhY3Rpb24sIGlnbm9yZSBxdWVyeVxuICAgICAgICBpZiAodGhpcyAmJiB0aGlzLnJvbGxiYWNrICYmIGFyZ3MubGVuZ3RoID09PSAwKSB7IHJldHVybiByZXNvbHZlKFtdKSB9XG4gICAgICAgIGNsaWVudC5xdWVyeSguLi5hcmdzLCBhc3luYyAoZXJyLCByZXN1bHRzKSA9PiB7XG4gICAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSA9PT0gJ1BST1RPQ09MX1NFUVVFTkNFX1RJTUVPVVQnKSB7XG4gICAgICAgICAgICBjbGllbnQuZGVzdHJveSgpIC8vIGRlc3Ryb3kgY29ubmVjdGlvbiBvbiB0aW1lb3V0XG4gICAgICAgICAgICByZXNldENsaWVudCgpIC8vIHJlc2V0IHRoZSBjbGllbnRcbiAgICAgICAgICAgIHJlamVjdChlcnIpIC8vIHJlamVjdCB0aGUgcHJvbWlzZSB3aXRoIHRoZSBlcnJvclxuICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICBlcnIgJiYgKC9eUFJPVE9DT0xfRU5RVUVVRV9BRlRFUl8vLnRlc3QoZXJyLmNvZGUpIFxuICAgICAgICAgICAgfHwgZXJyLmNvZGUgPT09ICdQUk9UT0NPTF9DT05ORUNUSU9OX0xPU1QnIFxuICAgICAgICAgICAgfHwgZXJyLmNvZGUgPT09ICdFUElQRSdcbiAgICAgICAgICAgIHx8IGVyci5jb2RlID09PSAnRUNPTk5SRVNFVCcpXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICByZXNldENsaWVudCgpIC8vIHJlc2V0IHRoZSBjbGllbnRcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHF1ZXJ5KC4uLmFyZ3MpKSAvLyBhdHRlbXB0IHRoZSBxdWVyeSBhZ2FpblxuICAgICAgICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICAgICAgICBpZiAodGhpcyAmJiB0aGlzLnJvbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGF3YWl0IHF1ZXJ5KCdST0xMQkFDSycpXG4gICAgICAgICAgICAgIHRoaXMucm9sbGJhY2soZXJyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVqZWN0KGVycilcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzdWx0cylcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gIH0gLy8gZW5kIHF1ZXJ5XG5cblxuICAvLyBHZXQgdGhlIG1heCBjb25uZWN0aW9ucyAoZWl0aGVyIGZvciB0aGlzIHVzZXIgb3IgdG90YWwpXG4gIGNvbnN0IGdldE1heENvbm5lY3Rpb25zID0gYXN5bmMgKCkgPT4ge1xuXG4gICAgLy8gSWYgY2FjaGUgaXMgZXhwaXJlZFxuICAgIGlmIChEYXRlLm5vdygpLV9tYXhDb25ucy51cGRhdGVkID4gbWF4Q29ubnNGcmVxKSB7XG5cbiAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgcXVlcnkoXG4gICAgICAgIGBTRUxFQ1QgSUYoQEBtYXhfdXNlcl9jb25uZWN0aW9ucyA+IDAsXG4gICAgICAgIExFQVNUKEBAbWF4X3VzZXJfY29ubmVjdGlvbnMsQEBtYXhfY29ubmVjdGlvbnMpLFxuICAgICAgICBAQG1heF9jb25uZWN0aW9ucykgQVMgdG90YWwsXG4gICAgICAgIElGKEBAbWF4X3VzZXJfY29ubmVjdGlvbnMgPiAwLHRydWUsZmFsc2UpIEFTIHVzZXJMaW1pdGBcbiAgICAgIClcblxuICAgICAgLy8gVXBkYXRlIF9tYXhDb25uc1xuICAgICAgX21heENvbm5zID0ge1xuICAgICAgICB0b3RhbDogcmVzdWx0c1swXS50b3RhbCB8fCAwLFxuICAgICAgICB1c2VyTGltaXQ6IHJlc3VsdHNbMF0udXNlckxpbWl0ID09PSAxID8gdHJ1ZSA6IGZhbHNlLFxuICAgICAgICB1cGRhdGVkOiBEYXRlLm5vdygpXG4gICAgICB9XG5cbiAgICB9IC8vIGVuZCBpZiByZW5ld2luZyBjYWNoZVxuXG4gICAgcmV0dXJuIF9tYXhDb25uc1xuXG4gIH0gLy8gZW5kIGdldE1heENvbm5lY3Rpb25zXG5cblxuICAvLyBHZXQgdGhlIHRvdGFsIGNvbm5lY3Rpb25zIGJlaW5nIHVzZWQgYW5kIHRoZSBsb25nZXN0IHNsZWVwIHRpbWVcbiAgY29uc3QgZ2V0VG90YWxDb25uZWN0aW9ucyA9IGFzeW5jICgpID0+IHtcblxuICAgIC8vIElmIGNhY2hlIGlzIGV4cGlyZWRcbiAgICBpZiAoRGF0ZS5ub3coKS1fdXNlZENvbm5zLnVwZGF0ZWQgPiB1c2VkQ29ubnNGcmVxKSB7XG5cbiAgICAgIGxldCByZXN1bHRzID0gYXdhaXQgcXVlcnkoXG4gICAgICAgIGBTRUxFQ1QgQ09VTlQoSUQpIGFzIHRvdGFsLCBNQVgodGltZSkgYXMgbWF4X2FnZVxuICAgICAgICBGUk9NIGluZm9ybWF0aW9uX3NjaGVtYS5wcm9jZXNzbGlzdFxuICAgICAgICBXSEVSRSAodXNlciA9ID8gQU5EIEBAbWF4X3VzZXJfY29ubmVjdGlvbnMgPiAwKSBPUiB0cnVlYCxbX2NmZy51c2VyXSlcblxuICAgICAgX3VzZWRDb25ucyA9IHtcbiAgICAgICAgdG90YWw6IHJlc3VsdHNbMF0udG90YWwgfHwgMCxcbiAgICAgICAgbWF4QWdlOiByZXN1bHRzWzBdLm1heF9hZ2UgfHwgMCxcbiAgICAgICAgdXBkYXRlZDogRGF0ZS5ub3coKVxuICAgICAgfVxuXG4gICAgfSAvLyBlbmQgaWYgcmVmcmVzaGluZyBjYWNoZVxuXG4gICAgcmV0dXJuIF91c2VkQ29ubnNcblxuICB9IC8vIGVuZCBnZXRUb3RhbENvbm5lY3Rpb25zXG5cblxuICAvLyBLaWxsIGFsbCB6b21iaWUgY29ubmVjdGlvbnMgdGhhdCBhcmUgb2xkZXIgdGhhbiB0aGUgdGhyZXNob2xkXG4gIGNvbnN0IGtpbGxab21iaWVDb25uZWN0aW9ucyA9IGFzeW5jICh0aW1lb3V0KSA9PiB7XG5cbiAgICBsZXQga2lsbGVkWm9tYmllcyA9IDBcblxuICAgIC8vIEh1bnQgZm9yIHpvbWJpZXMgKGp1c3QgdGhlIHNsZWVwaW5nIG9uZXMgdGhhdCB0aGlzIHVzZXIgb3ducylcbiAgICBsZXQgem9tYmllcyA9IGF3YWl0IHF1ZXJ5KFxuICAgICAgYFNFTEVDVCBJRCx0aW1lIEZST00gaW5mb3JtYXRpb25fc2NoZW1hLnByb2Nlc3NsaXN0XG4gICAgICAgIFdIRVJFIGNvbW1hbmQgPSAnU2xlZXAnIEFORCB0aW1lID49ID8gQU5EIHVzZXIgPSA/XG4gICAgICAgIE9SREVSIEJZIHRpbWUgREVTQ2AsXG4gICAgICBbIWlzTmFOKHRpbWVvdXQpID8gdGltZW91dCA6IDYwKjE1LCBfY2ZnLnVzZXJdKVxuXG4gICAgLy8gS2lsbCB6b21iaWVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB6b21iaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBxdWVyeSgnS0lMTCA/Jyx6b21iaWVzW2ldLklEKVxuICAgICAgICBvbktpbGwoem9tYmllc1tpXSkgLy8gZmlyZSBvbktpbGwgZXZlbnRcbiAgICAgICAga2lsbGVkWm9tYmllcysrXG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgLy8gaWYgKGUuY29kZSAhPT0gJ0VSX05PX1NVQ0hfVEhSRUFEJykgY29uc29sZS5sb2coZSlcbiAgICAgICAgb25LaWxsRXJyb3IoZSkgLy8gZmlyZSBvbktpbGxFcnJvciBldmVudFxuICAgICAgfVxuICAgIH0gLy8gZW5kIGZvclxuXG4gICAgcmV0dXJuIGtpbGxlZFpvbWJpZXNcblxuICB9IC8vIGVuZCBraWxsWm9tYmllQ29ubmVjdGlvbnNcblxuXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgLyoqICBUUkFOU0FDVElPTiBNQU5BR0VNRU5UICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICoqL1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgLy8gSW5pdCBhIHRyYW5zYWN0aW9uIG9iamVjdCBhbmQgcmV0dXJuIG1ldGhvZHNcbiAgY29uc3QgdHJhbnNhY3Rpb24gPSAoKSA9PiB7XG5cbiAgICBsZXQgcXVlcmllcyA9IFtdIC8vIGtlZXAgdHJhY2sgb2YgcXVlcmllc1xuICAgIGxldCByb2xsYmFjayA9ICgpID0+IHt9IC8vIGRlZmF1bHQgcm9sbGJhY2sgZXZlbnRcblxuICAgIHJldHVybiB7XG4gICAgICBxdWVyeTogZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBxdWVyaWVzLnB1c2goYXJnc1swXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxdWVyaWVzLnB1c2goKCkgPT4gWy4uLmFyZ3NdKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9LFxuICAgICAgcm9sbGJhY2s6IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHsgcm9sbGJhY2sgPSBmbiB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9LFxuICAgICAgY29tbWl0OiBhc3luYyBmdW5jdGlvbigpIHsgcmV0dXJuIGF3YWl0IGNvbW1pdChxdWVyaWVzLHJvbGxiYWNrKSB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ29tbWl0IHRyYW5zYWN0aW9uIGJ5IHJ1bm5pbmcgcXVlcmllc1xuICBjb25zdCBjb21taXQgPSBhc3luYyAocXVlcmllcyxyb2xsYmFjaykgPT4ge1xuXG4gICAgbGV0IHJlc3VsdHMgPSBbXSAvLyBrZWVwIHRyYWNrIG9mIHJlc3VsdHNcblxuICAgIC8vIFN0YXJ0IGEgdHJhbnNhY3Rpb25cbiAgICBhd2FpdCBxdWVyeSgnU1RBUlQgVFJBTlNBQ1RJT04nKVxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIHF1ZXJpZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIEV4ZWN1dGUgdGhlIHF1ZXJpZXMsIHBhc3MgdGhlIHJvbGxiYWNrIGFzIGNvbnRleHRcbiAgICAgIGxldCByZXN1bHQgPSBhd2FpdCBxdWVyeS5hcHBseSh7cm9sbGJhY2t9LHF1ZXJpZXNbaV0ocmVzdWx0c1tyZXN1bHRzLmxlbmd0aC0xXSxyZXN1bHRzKSlcbiAgICAgIC8vIEFkZCB0aGUgcmVzdWx0IHRvIHRoZSBtYWluIHJlc3VsdHMgYWNjdW11bGF0b3JcbiAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpXG4gICAgfVxuXG4gICAgLy8gQ29tbWl0IG91ciB0cmFuc2FjdGlvblxuICAgIGF3YWl0IHF1ZXJ5KCdDT01NSVQnKVxuXG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHRzXG4gICAgcmV0dXJuIHJlc3VsdHNcbiAgfVxuXG5cbiAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuICAvKiogIElOSVRJQUxJWkFUSU9OICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiovXG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbiAgY29uc3QgY2ZnID0gdHlwZW9mIHBhcmFtcyA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zKSA/IHBhcmFtcyA6IHt9XG5cbiAgTVlTUUwgPSBjZmcubGlicmFyeSB8fCByZXF1aXJlKCdteXNxbCcpXG4gIFByb21pc2VMaWJyYXJ5ID0gY2ZnLnByb21pc2UgfHwgUHJvbWlzZVxuXG4gIC8vIFNldCBkZWZhdWx0cyBmb3IgY29ubmVjdGlvbiBtYW5hZ2VtZW50XG4gIG1hbmFnZUNvbm5zID0gY2ZnLm1hbmFnZUNvbm5zID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSAvLyBkZWZhdWx0IHRvIHRydWVcbiAgY2FwID0gTnVtYmVyLmlzSW50ZWdlcihjZmcuY2FwKSA/IGNmZy5jYXAgOiAxMDAgLy8gZGVmYXVsdCB0byAxMDAgbXNcbiAgYmFzZSA9IE51bWJlci5pc0ludGVnZXIoY2ZnLmJhc2UpID8gY2ZnLmJhc2UgOiAyIC8vIGRlZmF1bHQgdG8gMiBtc1xuICBtYXhSZXRyaWVzID0gTnVtYmVyLmlzSW50ZWdlcihjZmcubWF4UmV0cmllcykgPyBjZmcubWF4UmV0cmllcyA6IDUwIC8vIGRlZmF1bHQgdG8gNTAgYXR0ZW1wdHNcbiAgYmFja29mZiA9IHR5cGVvZiBjZmcuYmFja29mZiA9PT0gJ2Z1bmN0aW9uJyA/IGNmZy5iYWNrb2ZmIDpcbiAgICBjZmcuYmFja29mZiAmJiBbJ2Z1bGwnLCdkZWNvcnJlbGF0ZWQnXS5pbmNsdWRlcyhjZmcuYmFja29mZi50b0xvd2VyQ2FzZSgpKSA/XG4gICAgICBjZmcuYmFja29mZi50b0xvd2VyQ2FzZSgpIDogJ2Z1bGwnIC8vIGRlZmF1bHQgdG8gZnVsbCBKaXR0ZXJcbiAgY29ublV0aWxpemF0aW9uID0gIWlzTmFOKGNmZy5jb25uVXRpbGl6YXRpb24pID8gY2ZnLmNvbm5VdGlsaXphdGlvbiA6IDAuOCAvLyBkZWZhdWx0IHRvIDAuN1xuICB6b21iaWVNaW5UaW1lb3V0ID0gTnVtYmVyLmlzSW50ZWdlcihjZmcuem9tYmllTWluVGltZW91dCkgPyBjZmcuem9tYmllTWluVGltZW91dCA6IDMgLy8gZGVmYXVsdCB0byAzIHNlY29uZHNcbiAgem9tYmllTWF4VGltZW91dCA9IE51bWJlci5pc0ludGVnZXIoY2ZnLnpvbWJpZU1heFRpbWVvdXQpID8gY2ZnLnpvbWJpZU1heFRpbWVvdXQgOiA2MCoxNSAvLyBkZWZhdWx0IHRvIDE1IG1pbnV0ZXNcbiAgbWF4Q29ubnNGcmVxID0gTnVtYmVyLmlzSW50ZWdlcihjZmcubWF4Q29ubnNGcmVxKSA/IGNmZy5tYXhDb25uc0ZyZXEgOiAxNSoxMDAwIC8vIGRlZmF1bHQgdG8gMTUgc2Vjb25kc1xuICB1c2VkQ29ubnNGcmVxID0gTnVtYmVyLmlzSW50ZWdlcihjZmcudXNlZENvbm5zRnJlcSkgPyBjZmcudXNlZENvbm5zRnJlcSA6IDAgLy8gZGVmYXVsdCB0byAwIG1zXG5cbiAgLy8gRXZlbnQgaGFuZGxlcnNcbiAgb25Db25uZWN0ID0gdHlwZW9mIGNmZy5vbkNvbm5lY3QgPT09ICdmdW5jdGlvbicgPyBjZmcub25Db25uZWN0IDogKCkgPT4ge31cbiAgb25Db25uZWN0RXJyb3IgPSB0eXBlb2YgY2ZnLm9uQ29ubmVjdEVycm9yID09PSAnZnVuY3Rpb24nID8gY2ZnLm9uQ29ubmVjdEVycm9yIDogKCkgPT4ge31cbiAgb25SZXRyeSA9IHR5cGVvZiBjZmcub25SZXRyeSA9PT0gJ2Z1bmN0aW9uJyA/IGNmZy5vblJldHJ5IDogKCkgPT4ge31cbiAgb25DbG9zZSA9IHR5cGVvZiBjZmcub25DbG9zZSA9PT0gJ2Z1bmN0aW9uJyA/IGNmZy5vbkNsb3NlIDogKCkgPT4ge31cbiAgb25FcnJvciA9IHR5cGVvZiBjZmcub25FcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IGNmZy5vbkVycm9yIDogKCkgPT4ge31cbiAgb25LaWxsID0gdHlwZW9mIGNmZy5vbktpbGwgPT09ICdmdW5jdGlvbicgPyBjZmcub25LaWxsIDogKCkgPT4ge31cbiAgb25LaWxsRXJyb3IgPSB0eXBlb2YgY2ZnLm9uS2lsbEVycm9yID09PSAnZnVuY3Rpb24nID8gY2ZnLm9uS2lsbEVycm9yIDogKCkgPT4ge31cblxuICBsZXQgY29ubkNmZyA9IHt9XG4gIFxuICBpZiAodHlwZW9mIGNmZy5jb25maWcgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGNmZy5jb25maWcpKSB7XG4gICAgY29ubkNmZyA9IGNmZy5jb25maWdcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09PSAnc3RyaW5nJykge1xuICAgIGNvbm5DZmcgPSBwYXJhbXNcbiAgfVxuXG4gIGxldCBlc2NhcGUgPSBNWVNRTC5lc2NhcGVcbiAgbGV0IGVzY2FwZUlkID0gTVlTUUwuZXNjYXBlSWRcbiAgbGV0IGZvcm1hdCA9IE1ZU1FMLmZvcm1hdFxuXG4gIC8vIFNldCBNeVNRTCBjb25maWdzXG4gIGNvbmZpZyhjb25uQ2ZnKVxuXG5cbiAgLy8gUmV0dXJuIHB1YmxpYyBtZXRob2RzXG4gIHJldHVybiB7XG4gICAgY29ubmVjdCxcbiAgICBjb25maWcsXG4gICAgcXVlcnksXG4gICAgZW5kLFxuICAgIGVzY2FwZSxcbiAgICBlc2NhcGVJZCxcbiAgICBmb3JtYXQsXG4gICAgcXVpdCxcbiAgICB0cmFuc2FjdGlvbixcbiAgICBnZXRDb3VudGVyLFxuICAgIGdldENsaWVudCxcbiAgICBnZXRDb25maWcsXG4gICAgZ2V0RXJyb3JDb3VudFxuICB9XG5cbn0gLy8gZW5kIGV4cG9ydHNcbiJdLCJuYW1lcyI6WyJOb2RlVVJMIiwicmVxdWlyZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJwYXJhbXMiLCJjbGllbnQiLCJjb3VudGVyIiwiZXJyb3JzIiwicmV0cmllcyIsIl9jZmciLCJfbWF4Q29ubnMiLCJ1cGRhdGVkIiwiX3VzZWRDb25ucyIsInRvb01hbnlDb25uc0Vycm9ycyIsIk1ZU1FMIiwibWFuYWdlQ29ubnMiLCJjYXAiLCJiYXNlIiwibWF4UmV0cmllcyIsImNvbm5VdGlsaXphdGlvbiIsImJhY2tvZmYiLCJ6b21iaWVNaW5UaW1lb3V0Iiwiem9tYmllTWF4VGltZW91dCIsIm1heENvbm5zRnJlcSIsInVzZWRDb25uc0ZyZXEiLCJvbkNvbm5lY3QiLCJvbkNvbm5lY3RFcnJvciIsIm9uUmV0cnkiLCJvbkNsb3NlIiwib25FcnJvciIsIm9uS2lsbCIsIm9uS2lsbEVycm9yIiwiUHJvbWlzZUxpYnJhcnkiLCJnZXRDb3VudGVyIiwiaW5jQ291bnRlciIsInJlc2V0Q291bnRlciIsImdldENsaWVudCIsInJlc2V0Q2xpZW50IiwicmVzZXRSZXRyaWVzIiwiZ2V0RXJyb3JDb3VudCIsImdldENvbmZpZyIsImNvbmZpZyIsImFyZ3MiLCJPYmplY3QiLCJhc3NpZ24iLCJ1cmlUb0Nvbm5lY3Rpb25Db25maWciLCJkZWxheSIsIm1zIiwicmVzIiwic2V0VGltZW91dCIsInJhbmRSYW5nZSIsIm1pbiIsIm1heCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImZ1bGxKaXR0ZXIiLCJkZWNvcnJlbGF0ZWRKaXR0ZXIiLCJzbGVlcCIsImNvbm5lY3Rpb25TdHJpbmciLCJ1cmkiLCJ1bmRlZmluZWQiLCJVUkwiLCJlcnJvciIsIkVycm9yIiwiZXh0cmFGaWVsZHMiLCJuYW1lIiwidmFsdWUiLCJzZWFyY2hQYXJhbXMiLCJkYXRhYmFzZSIsInBhdGhuYW1lIiwic3RhcnRzV2l0aCIsInNsaWNlIiwiY29ubmVjdGlvbkZpZWxkcyIsImhvc3QiLCJob3N0bmFtZSIsInVzZXIiLCJ1c2VybmFtZSIsInBvcnQiLCJOdW1iZXIiLCJwYXNzd29yZCIsImNvbm5lY3QiLCJ3YWl0IiwiX2Nvbm5lY3QiLCJlIiwiaW5jbHVkZXMiLCJjb2RlIiwiaXNJbnRlZ2VyIiwidGhlbiIsInJlc29sdmUiLCJyZWplY3QiLCJjcmVhdGVDb25uZWN0aW9uIiwiZXJyIiwib24iLCJlbmQiLCJtYXhDb25ucyIsImdldE1heENvbm5lY3Rpb25zIiwidXNlZENvbm5zIiwiZ2V0VG90YWxDb25uZWN0aW9ucyIsInRvdGFsIiwidGltZW91dCIsIm1heEFnZSIsImtpbGxlZFpvbWJpZXMiLCJraWxsWm9tYmllQ29ubmVjdGlvbnMiLCJxdWl0IiwicXVlcnkiLCJyb2xsYmFjayIsImxlbmd0aCIsInJlc3VsdHMiLCJkZXN0cm95IiwidGVzdCIsIkRhdGUiLCJub3ciLCJ1c2VyTGltaXQiLCJtYXhfYWdlIiwiem9tYmllcyIsImlzTmFOIiwiaSIsIklEIiwidHJhbnNhY3Rpb24iLCJxdWVyaWVzIiwicHVzaCIsImZuIiwiY29tbWl0IiwicmVzdWx0IiwiYXBwbHkiLCJjZmciLCJBcnJheSIsImlzQXJyYXkiLCJsaWJyYXJ5IiwicHJvbWlzZSIsIlByb21pc2UiLCJ0b0xvd2VyQ2FzZSIsImNvbm5DZmciLCJlc2NhcGUiLCJlc2NhcGVJZCIsImZvcm1hdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/serverless-mysql/index.js\n");

/***/ })

};
;